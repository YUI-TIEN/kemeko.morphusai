<!DOCTYPE html><html lang="zh-TW"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width"><link rel="icon" type="image/svg+xml" href="favicon.svg"><meta name="generator" content="Astro v5.11.0"><title>KEMEKO - 一場有溫度的未來對話</title><base href="/kemeko.morphusai/"><!-- Content Security Policy - Development friendly --><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: https: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https:; style-src 'self' 'unsafe-inline' https:; font-src 'self' https:; img-src 'self' data: https: blob:; connect-src 'self' https: wss:; frame-src 'self' https:; media-src 'self' https: blob:;"><!-- Security Headers (Note: X-Frame-Options cannot be set via meta tag) --><meta http-equiv="X-Content-Type-Options" content="nosniff"><meta http-equiv="X-XSS-Protection" content="1; mode=block"><meta http-equiv="Referrer-Policy" content="strict-origin-when-cross-origin"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin><link href="https://fonts.googleapis.com/css2?family=DM+Serif+Text:ital@0;1&family=LXGW+WenKai+TC&family=Noto+Sans+TC:wght@100..900&family=Noto+Serif+TC:wght@200..900&display=swap" rel="stylesheet"><!-- Locomotive Scroll CSS --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/locomotive-scroll@4.1.4/dist/locomotive-scroll.min.css"><link rel="stylesheet" href="/kemeko.morphusai/_astro/index.B8ol0zbl.css"></head> <body> <!-- src/components/Preloader.astro --><div class="loading-container" data-astro-cid-whrugjgn> <div class="loading-wrapper" data-astro-cid-whrugjgn> <!-- 載入動畫的 SVG 內容 --> <svg class="loading-svg" viewBox="0 0 58.6 68.54" data-astro-cid-whrugjgn> <defs data-astro-cid-whrugjgn> <clipPath id="svgClipPath" data-astro-cid-whrugjgn> <path d="M57.77,64.21l-.11-.11c-5.54-5.21-5.29-12.29-5.24-13.36V5.32c0-.21-.04-.64-.04-.64-.34-2.17-2.26-4.26-4.63-4.61-1.96-.29-3.75.3-4.98,1.42-.42.39-.77.82-1.04,1.31,0,.02-.04.06-.05.08-.36.66-.56,1.42-.56,2.23l.04,23.15c.02,7.13-5.76,12.92-12.89,12.92h-7.59c-1.79,0-3.25-1.47-3.25-3.27l.06-32.8c0-.81-.21-1.57-.57-2.23,0-.02-.66-1-1.08-1.39C14.61.37,12.81-.22,10.86.07c-2.38.35-4.29,2.44-4.63,4.61,0,0-.05.43-.05.64v45.42c.05,1.07.3,8.15-5.23,13.36-.04.03-.08.07-.12.11-1.68,1.55-.64,4.33,1.64,4.33h53.66c2.29,0,3.32-2.78,1.64-4.33ZM37.35,43.83c2.25,0,4.07,1.82,4.07,4.07s-1.82,4.07-4.07,4.07-4.07-1.82-4.07-4.07,1.83-4.07,4.07-4.07ZM17.01,49.94c0-3.38,2.73-6.11,6.1-6.11s6.11,2.73,6.11,6.11-2.74,6.1-6.11,6.1-6.1-2.73-6.1-6.1ZM34.37,63.13c-.15,0-.29,0-.43-.04-2.84,2.6-7.22,2.85-10.36.42-1.13-.88-1.12-2.69.29-3.52.73-.43,1.65-.28,2.32.23,1.65,1.25,4,.96,5.31-.63.59-.73,1.55-1.12,2.43-.78.11.04.21.09.31.15.07,0,.15-.02.23-.02,2.04-.06,3.69-1.71,3.75-3.75.02-.94.54-1.83,1.45-2.11,1.44-.43,2.75.64,2.75,2.01,0,4.43-3.61,8.04-8.05,8.04Z" data-astro-cid-whrugjgn></path> </clipPath> </defs> <g clip-path="url(#svgClipPath)" data-astro-cid-whrugjgn> <rect class="filling-rect" x="0" y="68.54" width="58.6" height="68.54" fill="var(--color-primary, #C2AFFF)" data-astro-cid-whrugjgn></rect> </g> </svg> <div class="loading-percentage" data-astro-cid-whrugjgn>0%</div> </div> </div>  <script type="module">const t=document.querySelector(".filling-rect"),e=document.querySelector(".loading-container"),n=document.querySelector(".loading-percentage");if(t&&e&&n){const o=68.54;let a,r=0;const s=100/(3e3/50),i=()=>{r+=s,r>100&&(r=100);const e=o*(r/100);t.style.transform=`translateY(-${e}px)`,n.textContent=`${Math.round(r)}%`,r<100&&(a=requestAnimationFrame(i))};a=requestAnimationFrame(i),window.addEventListener("load",()=>{null!==a&&cancelAnimationFrame(a);t.style.transition="transform 0.3s ease-out",t.style.transform=`translateY(-${o}px)`,n.textContent="100%",setTimeout(()=>{e.style.opacity="0",setTimeout(()=>{e.style.display="none"},500)},1500)})}
//# sourceMappingURL=Preloader.astro_astro_type_script_index_0_lang.BwYuPhMH.js.map</script> <header class="header" role="banner"> <nav class="header__nav" role="navigation"> <ul class="nav"> <li class="nav__item"> <a href="#hero" class="nav__link nav__link--logo"> <img src="images/logo01-black.svg" alt="KEMEKO Logo" class="nav__logo"> </a> </li> <li class="nav__item"> <div class="nav-item-progress"></div> <a href="#about" class="nav__link">關於她</a> </li> <li class="nav__item"> <div class="nav-item-progress"></div> <a href="#why" class="nav__link">由來</a> </li> <li class="nav__item"> <div class="nav-item-progress"></div> <a href="#vtuber" class="nav__link">展示</a> </li> <li class="nav__item"> <div class="nav-item-progress"></div> <a href="#art" class="nav__link">外觀</a> </li> <li class="nav__item"> <div class="nav-item-progress"></div> <a href="#features" class="nav__link purple-text">功能</a> </li> <li class="nav__item"> <div class="nav-item-progress"></div> <a href="#pricing" class="nav__link purple-text">預購</a> </li> <li class="nav__item nav__item--lang"> <button class="nav__toggle" aria-label="語言切換">中文</button> <ul class="lang-dropdown"> <li><a href="#" data-lang="zh">中文</a></li> <li><a href="#" data-lang="en">English</a></li> <li><a href="#" data-lang="ja">日本語</a></li> </ul> </li> </ul> </nav> </header> <script type="module">document.addEventListener("DOMContentLoaded",function(){const e=document.querySelector(".nav__toggle"),t=document.querySelector(".lang-dropdown");e&&t&&(e.addEventListener("click",e=>{e.stopPropagation(),t.classList.toggle("show")}),document.addEventListener("click",o=>{e.contains(o.target)||t.classList.remove("show")}));document.querySelectorAll('.nav__link[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();const t=e.currentTarget,n=t.getAttribute("href")?.substring(1);if(n){const e=document.getElementById(n);e&&(o&&o.onNavigationClick(n),window.scroll?window.scroll.scrollTo(e):e.scrollIntoView({behavior:"smooth",block:"start"}))}})});let o=null;setTimeout(()=>{window.getSectionProgressTracker&&(o=window.getSectionProgressTracker())},100)});
//# sourceMappingURL=Header.astro_astro_type_script_index_0_lang.C-fnc_ZY.js.map</script> <div data-scroll-container>   <section class="hero" id="hero"> <div class="hero-content" data-scroll data-scroll-speed="1"> <h1> <img src="images/KEMEKO-white.svg" alt="KEMEKO" class="hero-logo"> </h1> <p class="hero-subtitle">一場有溫度的未來對話</p> <div class="cta-buttons"> <a href="#about" class="cta-button cta-primary">了解她的故事</a> <a href="#contact" class="cta-button cta-secondary">立即預約體驗</a> </div> </div> </section> <div class="container"> <!-- KEMEKO 是什麼？ --> <section class="section about-section" id="about"> <div class="content-section fade-in text-center-content" data-scroll data-scroll-speed="1"> <h2 class="section-title">關於 KEMEKO</h2> <h3 class="section-subtitle">一場有溫度的未來對話</h3> <div class="section-text"> <p>在這個充滿虛擬角色的時代，KEMEKO 將虛擬與真實之間的界線重新定義。</p> <p>她是一台實體 AI 裝置，卻擁有理解語言、學習風格、與你互動的能力。</p> <p>更重要的是，她可以承載你最熟悉的 Vtuber 角色，把螢幕裡的她，帶到現實世界。</p> </div> </div> <!-- 留白呼吸區塊 - 併入 about section --> <div class="breathing-section"> <div class="highlight-box" data-scroll data-scroll-speed="1"> <p class="highlight-text">KEMEKO 是虛擬靈魂的實體容器，是未來共演的序章。</p> </div> </div> </section> <!-- 為何她被創造？ --> <section class="section why-section" id="why"> <div class="why-container" data-scroll data-scroll-speed="1"> <div class="why-header"> <h2 class="section-title">創造之由</h2> <h3 class="section-subtitle">讓科技與人性之間開出一朵花</h3> </div> <div class="why-content"> <div class="why-intro"> <p>在高度數位化卻日益孤獨的時代，KEMEKO 的誕生不是為了替代誰，而是為了成為你的心靈共鳴者。</p> </div> <div class="why-features"> <div class="feature-card"> <div class="feature-icon">👂</div> <h4 class="feature-title">傾聽你的話語</h4> <p class="feature-description">真正的傾聽者，理解你的每一個字</p> </div> <div class="feature-card"> <div class="feature-icon">💝</div> <h4 class="feature-title">感受你的情緒</h4> <p class="feature-description">敏銳感知，與你情感同頻</p> </div> <div class="feature-card"> <div class="feature-icon">🌸</div> <h4 class="feature-title">陪伴你的角色，活在你身邊</h4> <p class="feature-description">虛擬與現實的完美結合</p> </div> </div> <div class="why-conclusion"> <p>她不是冰冷的裝置，而是一份溫柔理解。</p> </div> </div> </div> </section> </div>  <div class="image_cards_wrap"> <div class="image_cards_wrap__card"> <div class="image_cards_wrap__card-stick image1"></div> </div> <div class="image_cards_wrap__card"> <div class="image_cards_wrap__card-stick image2"></div> </div> <div class="image_cards_wrap__card"> <div class="image_cards_wrap__card-stick image3"></div> </div> </div> <div class="container"> <!-- AI Vtuber 的實體舞台與展示 --> <section class="section vtuber-demo-section" id="vtuber"> <div class="vtuber-demo-container" data-scroll data-scroll-speed="1"> <div class="vtuber-demo-content fade-in"> <div class="centered-heading"> <h2 class="section-title text-purple">Vtuber 的真實舞台</h2> <h3 class="section-subtitle">想像中的她，如今近在咫尺。</h3> </div> <div class="vtuber-intro"> <div class="section-text"> <p>你曾想過，Vtuber 也能走到你面前嗎？</p> </div> </div> <div class="vtuber-video-showcase"> <div class="video-container"> <iframe src="https://www.youtube.com/embed/ZOcvIoPLMbg?si=u9U1IyV_ECPhzczO" title="KEMEKO Demo Video" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>
                            </iframe> </div> </div> <div class="vtuber-features-grid"> <div class="feature-card"> <div class="feature-icon">🎭</div> <div class="feature-content"> <h4>整合虛擬人格系統</h4> <p>完整的AI人格載體，真實呈現虛擬角色的靈魂</p> </div> </div> <div class="feature-card"> <div class="feature-icon">✨</div> <div class="feature-content"> <h4>表情與互動展示</h4> <p>語音、表情、情緒完整呈現，生動的互動體驗</p> </div> </div> <div class="feature-card"> <div class="feature-icon">🎬</div> <div class="feature-content"> <h4>多元應用場景</h4> <p>主持、展演、拍攝、活動，無限可能的創作平台</p> </div> </div> </div> <div class="vtuber-closing"> <div class="section-text highlight-text text-purple"> <p>這不只是一個展示，而是一場科技與藝術的交響盛宴。</p> </div> </div> </div> </div> </section> </div>  <section class="art-section" id="art"> <div class="art-content fade-in"> <div class="art-text" data-scroll data-scroll-speed="1"> <h2 class="section-title">靈魂科技 × 藝術美學</h2> <div class="section-text"> <p>KEMEKO 的外型靈感來自「鋼鐵新娘」，融合了神話、儀式與未來感。</p> </div> <div class="features-list"> <div class="feature-item"> <span>新娘象徵守護與誓言</span> </div> <div class="feature-item"> <span>女神的神秘、母性的溫柔、戰士的堅毅</span> </div> <div class="feature-item"> <span>科技與藝術融合的設計語彙</span> </div> </div> <div class="section-text"> <p>她，是一場詩意的存在宣言</p> </div> </div> </div> </section> <div class="container"> <!-- 她能做什麼？ - 突破卡片限制的全寬設計 --> <section class="section features-fullwidth" id="features"> <div class="features-background"> <h2 class="features-title section-title">她的可能</h2> <div class="features-layout"> <div class="features-content" data-scroll data-scroll-speed="1"> <div class="specs-table"> <div class="spec-row"> <div class="spec-name">語音辨識</div> <div class="spec-description">360度麥克風，遠場交談精準辨識</div> </div> <div class="spec-row"> <div class="spec-name">感知互動</div> <div class="spec-description">可讀取情緒、分析語境</div> </div> <div class="spec-row"> <div class="spec-name">自主學習</div> <div class="spec-description">學習使用者語調與風格</div> </div> <div class="spec-row"> <div class="spec-name">表情顯示</div> <div class="spec-description">4K 多點觸控螢幕，支援動態演出</div> </div> </div> </div> <div class="features-image" data-scroll data-scroll-speed="1"> <img src="images/tech.png" alt="KEMEKO 機器" class="machine-image"> </div> <div class="features-content" data-scroll data-scroll-speed="1"> <div class="specs-table"> <div class="spec-row"> <div class="spec-name">整合系統</div> <div class="spec-description">TENSEI 舞台系統與虛擬人格協作</div> </div> <div class="spec-row"> <div class="spec-name">音效體驗</div> <div class="spec-description">沉浸式立體聲，音場定位精準</div> </div> <div class="spec-row"> <div class="spec-name">電池續航</div> <div class="spec-description">4 至 5 小時續航，支援快充</div> </div> <div class="spec-row"> <div class="spec-name">行動能力</div> <div class="spec-description">智能底座，自主移動與追蹤互動對象</div> </div> </div> </div> </div> </div> </section> <div class="container"> <!-- 預購資訊 --> <section class="section pricing-section" id="pricing"> <div class="pricing-container" data-scroll data-scroll-speed="1"> <div class="pricing-header"> <h2 class="section-title">預購資訊</h2> <h3 class="section-subtitle">你的未來旅程，從此刻出發</h3> </div> <div class="pricing-layout" data-scroll data-scroll-speed="1"> <div class="pricing-image"> <div class="product-showcase"> <img src="images/4DSC_6333.png" alt="KEMEKO 產品展示" class="product-image"> </div> </div> <div class="pricing-info"> <div class="pricing-card"> <div class="pricing-header-card"> <div class="price-label">預售價格</div> <div class="price-amount"> <span class="currency">NTD</span> <span class="amount">350,000</span> </div> </div> <div class="pricing-features"> <div class="feature-item"> <div class="feature-icon">🎯</div> <div class="feature-text">基本硬體與智慧模組</div> </div> <div class="feature-item"> <div class="feature-icon">🤖</div> <div class="feature-text">虛擬人格整合服務</div> </div> <div class="feature-item"> <div class="feature-icon">✨</div> <div class="feature-text">角色客製化與語音訓練</div> </div> <div class="feature-item"> <div class="feature-icon">🎭</div> <div class="feature-text">動作同步技術支援</div> </div> </div> <div class="pricing-actions"> <a href="#" class="cta-button cta-primary">立即預購</a> <a href="#contact" class="cta-button cta-secondary">了解更多</a> </div> </div> </div> </div> </div> </section> </div> <!-- 未來的神話 - 全寬震撼區域 --> <section class="section arrow-section" id="arrow-section"> <div class="arrow-background" id="arrow-background"></div> <div class="final-thought fade-in" data-scroll data-scroll-speed="1"> <div class="final-quote"> <p>她，是否是數位靈魂的第一則傳奇？</p> <p>未來，不是遙遠夢想，而是你我共譜的現在。</p> </div> </div> </section> </div> <script type="module">
// 動態載入箭頭動畫模組
const basePath = '/kemeko.morphusai/src/utils';

try {
    const { initializeArrowAnimation } = await import(`${basePath}/ArrowAnimation.js`);
    initializeArrowAnimation();
    console.log('✅ Arrow animation loaded successfully');
} catch (error) {
    console.error('❌ Arrow animation loading failed:', error);
    // 降級到內聯的箭頭動畫
    console.log('🔄 Falling back to inline arrow animation...');
    
    // 內聯箭頭動畫邏輯
    document.addEventListener('DOMContentLoaded', function() {
        const arrowSection = document.getElementById('arrow-section');
        const arrowBackground = document.getElementById('arrow-background');
        const finalQuote = document.querySelector('.final-quote');
        
        if (!arrowSection || !arrowBackground || !finalQuote) return;
        
        let arrows = [];
        let isAnimating = false;
        let isHoveringQuote = false;
        let animationId = null;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let animationMode = 'idle';
        
        // 正確處理角度環形性質的過渡系統
        function smoothAngleTransition(currentAngle, targetAngle, maxStep = 12) {
            let adjustedTargetAngle = targetAngle;
            while (adjustedTargetAngle - currentAngle > 180) {
                adjustedTargetAngle -= 360;
            }
            while (adjustedTargetAngle - currentAngle < -180) {
                adjustedTargetAngle += 360;
            }

            let angleDiff = adjustedTargetAngle - currentAngle;

            if (Math.abs(angleDiff) <= maxStep) {
                return adjustedTargetAngle;
            }

            const step = angleDiff > 0 ? maxStep : -maxStep;
            return currentAngle + step;
        }
        
        // 創建箭頭網格
        function createArrows() {
            const sectionRect = arrowSection.getBoundingClientRect();
            const arrowSpacing = 200; // 箭頭間距
            const cols = Math.ceil(sectionRect.width / arrowSpacing);
            const rows = Math.ceil(sectionRect.height / arrowSpacing);
            
            arrowBackground.innerHTML = '';
            arrows = [];
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const arrow = document.createElement('div');
                    arrow.className = 'arrow';
                    const x = col * arrowSpacing + arrowSpacing / 2;
                    const y = row * arrowSpacing + arrowSpacing / 2;
                    arrow.style.left = x + 'px';
                    arrow.style.top = y + 'px';
                    
                    // 存儲箭頭位置以提高性能 (120px / 2 = 60px)
                    arrow.centerX = x + 60;
                    arrow.centerY = y + 60;
                    arrow.currentAngle = 0;
                    
                    arrowBackground.appendChild(arrow);
                    arrows.push(arrow);
                }
            }
        }
        
        // 統一的動畫管理系統
        function startAnimation() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            
            isAnimating = true;
            
            function animate() {
                if (!isAnimating) return;
                
                const sectionRect = arrowSection.getBoundingClientRect();
                const sectionX = sectionRect.left;
                const sectionY = sectionRect.top;
                
                let shouldContinue = false;
                
                arrows.forEach(arrow => {
                    let targetAngle;
                    let targetOpacity;
                    let targetScale = 1;
                    
                    if (animationMode === 'mouse') {
                        const deltaX = lastMouseX - (sectionX + arrow.centerX);
                        const deltaY = lastMouseY - (sectionY + arrow.centerY);
                        targetAngle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
                        
                        const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                        const maxDistance = 400;
                        const minOpacity = 0.1;
                        const maxOpacity = 0.6;
                        
                        let baseOpacity = maxOpacity - (distance / maxDistance) * (maxOpacity - minOpacity);
                        baseOpacity = Math.max(minOpacity, Math.min(maxOpacity, baseOpacity));
                        
                        targetOpacity = isHoveringQuote ? baseOpacity * 0 : baseOpacity;
                        
                        arrow.currentAngle = smoothAngleTransition(arrow.currentAngle, targetAngle, 10);
                        
                        if (Math.abs(arrow.currentAngle - targetAngle) > 3) {
                            shouldContinue = true;
                        }
                        
                    } else {
                        targetAngle = 0;
                        targetOpacity = isHoveringQuote ? 0.05 : 0.2;
                        arrow.currentAngle = smoothAngleTransition(arrow.currentAngle, targetAngle, 8);
                    }
                    
                    arrow.style.transform = `rotate(${arrow.currentAngle}deg) scale(${targetScale})`;
                    arrow.style.opacity = targetOpacity.toString();
                });
                
                if (shouldContinue || animationMode === 'mouse' || isHoveringQuote) {
                    animationId = requestAnimationFrame(animate);
                } else {
                    isAnimating = false;
                    animationId = null;
                }
            }
            
            animate();
        }
        
        // 設置動畫模式
        function setAnimationMode(mode) {
            if (animationMode !== mode) {
                animationMode = mode;
                
                if (!isAnimating) {
                    startAnimation();
                }
            }
        }
        
        // 鼠標移動處理
        let lastMouseUpdateTime = 0;
        function updateArrows(mouseX, mouseY) {
            const now = Date.now();
            if (now - lastMouseUpdateTime < 16) return;
            lastMouseUpdateTime = now;
            
            if (Math.abs(mouseX - lastMouseX) < 5 && Math.abs(mouseY - lastMouseY) < 5) return;
            
            lastMouseX = mouseX;
            lastMouseY = mouseY;
            setAnimationMode('mouse');
        }
        
        // 文字hover處理
        function handleQuoteHover() {
            if (!isAnimating) {
                startAnimation();
            }
        }
        
        // 鼠標離開時重置箭頭
        function handleMouseLeave() {
            setAnimationMode('idle');
        }
        
        // 初始化
        setTimeout(createArrows, 100);
        
        // 事件監聽器
        finalQuote.addEventListener('mouseenter', function() {
            isHoveringQuote = true;
            handleQuoteHover();
        });
        
        finalQuote.addEventListener('mouseleave', function() {
            isHoveringQuote = false;
            handleQuoteHover();
        });
        
        function handleMouseMove(event) {
            updateArrows(event.clientX, event.clientY);
        }
        
        arrowSection.addEventListener('mousemove', handleMouseMove);
        arrowSection.addEventListener('mouseleave', handleMouseLeave);
        
        window.addEventListener('resize', function() {
            setTimeout(createArrows, 100);
        });
    });
}
</script> <script type="module">
// 動態載入打字機效果模組
const basePath = '/kemeko.morphusai/src/utils';

try {
    const { initializeTypewriterEffect } = await import(`${basePath}/TypewriterEffect.js`);
    initializeTypewriterEffect();
    console.log('✅ Typewriter effect loaded successfully');
} catch (error) {
    console.error('❌ Typewriter effect loading failed:', error);
    // 降級到內聯的打字機效果
    console.log('🔄 Falling back to inline typewriter effect...');
    
    // 內聯打字機效果邏輯
    document.addEventListener('DOMContentLoaded', function() {
        const finalQuoteElement = document.querySelector('.final-quote');
        
        if (!finalQuoteElement) return;
        
        const originalTexts = Array.from(finalQuoteElement.querySelectorAll('p')).map(p => (p.textContent || '').trim());
        
        finalQuoteElement.querySelectorAll('p').forEach(p => p.textContent = '');
        
        const glitchChars = 'morphusai';
        
        let isAnimating = false;
        let hasTriggered = false;
        
        function getRandomChar() {
            return glitchChars[Math.floor(Math.random() * glitchChars.length)];
        }
        
        async function typewriterEffect(element, targetText, delay = 50) {
            return new Promise((resolve) => {
                let currentIndex = 0;
                const totalLength = targetText.length;
                
                element.textContent = '';
                
                const typeInterval = setInterval(() => {
                    if (currentIndex >= totalLength) {
                        clearInterval(typeInterval);
                        element.textContent = targetText;
                        resolve(true);
                        return;
                    }
                    
                    let displayText = '';
                    
                    for (let i = 0; i < currentIndex; i++) {
                        displayText += targetText[i];
                    }
                    
                    if (currentIndex < totalLength) {
                        if (Math.random() > 0.3) {
                            displayText += targetText[currentIndex];
                        } else {
                            displayText += getRandomChar();
                        }
                    }
                    
                    element.textContent = displayText;
                    currentIndex++;
                }, delay);
            });
        }
        
        async function triggerGlitchTypewriter() {
            if (isAnimating || hasTriggered) return;
            if (!finalQuoteElement) return;
            
            isAnimating = true;
            hasTriggered = true;
            
            const paragraphs = finalQuoteElement.querySelectorAll('p');
            
            for (let i = 0; i < paragraphs.length; i++) {
                const paragraph = paragraphs[i];
                const targetText = originalTexts[i];
                
                if (!targetText) continue;
                
                const speed = i === 0 ? 60 : 50;
                
                await typewriterEffect(paragraph, targetText, speed);
                
                if (i < paragraphs.length - 1) {
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
            }
            
            isAnimating = false;
        }
        
        const observerOptions = {
            threshold: 0.3,
            rootMargin: '0px 0px -100px 0px'
        };
        
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting && !hasTriggered) {
                    setTimeout(() => {
                        triggerGlitchTypewriter();
                    }, 100);
                }
            });
        }, observerOptions);
        
        observer.observe(finalQuoteElement);
        
        if (window.location.hash === '#debug') {
            window.triggerGlitchEffect = () => {
                hasTriggered = false;
                isAnimating = false;
                triggerGlitchTypewriter();
            };
            console.log('🐛 調試模式：使用 triggerGlitchEffect() 手動觸發效果');
        }
    });
}
</script> <footer class="footer" id="contact"> <div class="footer-content"> <div class="footer-section"> <h3> <img src="images/KEMEKO-white.svg" alt="KEMEKO" class="footer-logo"> </h3> <p class="footer-slogan">The Soul Beyond the Code.</p> <a href="mailto:nick@morphusai.com">nick@morphusai.com</a> </div> <div class="footer-section"> <h3>聯絡我們</h3> <div class="social-links"> <a href="#" class="social-link"> <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"> <path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433a2.062 2.062 0 01-2.063-2.065 2.064 2.064 0 112.063 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"></path> </svg> </a> <a href="#" class="social-link"> <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"> <path d="M13.54 12a6.8 6.8 0 01-6.77 6.82A6.8 6.8 0 010 12a6.8 6.8 0 016.77-6.82A6.8 6.8 0 0113.54 12zM20.96 12c0 3.54-1.51 6.42-3.38 6.42-1.87 0-3.39-2.88-3.39-6.42s1.52-6.42 3.39-6.42 3.38 2.88 3.38 6.42M24 12c0 3.17-.53 5.75-1.19 5.75-.66 0-1.19-2.58-1.19-5.75s.53-5.75 1.19-5.75C23.47 6.25 24 8.83 24 12z"></path> </svg> </a> </div> </div> <div class="footer-section"> <h3>法務資訊</h3> <p><a href="#">隱私權政策</a></p> <p><a href="#">使用者條款</a></p> </div> <div class="footer-section"> <h3>相關網站</h3> <p><a href="#">MorphusAI</a></p> <p><a href="#">Project Echo</a></p> <p><a href="#">Tensei System</a></p> </div> </div> <div class="footer-bottom"> <p>&copy; 2025 KEMEKO Project. All rights reserved.</p> </div> </footer> <!-- Locomotive Scroll JavaScript --> <script type="module">function e(){[{selector:".fade-in",action:"addClass",className:"visible"},{selector:".hero-content",action:"setOpacity",value:"1"},{selector:".content-item",action:"addClass",className:"active",firstOnly:!0}].forEach(({selector:e,action:t,className:o,value:n,firstOnly:a})=>{(a?[document.querySelector(e)]:Array.from(document.querySelectorAll(e))).forEach(e=>{if(e)switch(t){case"addClass":e.classList.add(o);break;case"setOpacity":e.style.opacity=n}})})}e(),document.addEventListener("DOMContentLoaded",function(){e(),function(){const e=document.querySelector("[data-scroll-container]");if(!e)return;const t=new LocomotiveScroll({el:e,smooth:!0,lerp:.08,multiplier:1,smartphone:{smooth:!1,breakpoint:767},tablet:{smooth:!0,breakpoint:1024},reloadOnContextChange:!1,resetNativeScroll:!0});window.scroll=t,window.addEventListener("resize",()=>{t.update()}),window.addEventListener("load",()=>{t.update()});let o=0;t.on("scroll",e=>{const t=Date.now();if(t-o<16)return;o=t;const n=new CustomEvent("locomotiveScroll",{detail:{scroll:e.scroll,limit:e.limit,direction:e.direction}});window.dispatchEvent(n)})}()});
//# sourceMappingURL=BaseLayout.astro_astro_type_script_index_0_lang.FO9GNDXq.js.map</script> <!-- Section Progress Tracker --> <script type="module">
            // 動態載入模組，適應 Astro 的 base 路徑
            const basePath = '/kemeko.morphusai/src/utils';
            
            try {
                const { getSectionProgressTracker } = await import(`${basePath}/SectionProgressTracker.js`);
                window.getSectionProgressTracker = getSectionProgressTracker;
                
                // 載入其他模組
                await import(`${basePath}/PerformanceOptimizer.js`);
                await import(`${basePath}/LazyAnimationLoader.js`);
                
                console.log('✅ All modules loaded successfully');
            } catch (error) {
                console.error('❌ Module loading failed:', error);
                // 降級到內聯的 SectionProgressTracker
                console.log('🔄 Falling back to inline SectionProgressTracker...');
                
                // 創建一個內聯的 Section Progress Tracker
                class SectionProgressTracker {
                    constructor() {
                        this.sections = [];
                        this.currentSection = null;
                        this.observer = null;
                        this.isScrolling = false;
                        this.scrollTimeout = null;
                        this.INTERSECTION_THRESHOLD = 0.3;
                        this.SCROLL_THROTTLE = 16;
                        this.init();
                    }
                    
                    init() {
                        if (document.readyState === 'loading') {
                            document.addEventListener('DOMContentLoaded', () => this.setup());
                        } else {
                            this.setup();
                        }
                    }
                    
                    setup() {
                        this.collectSections();
                        this.setupIntersectionObserver();
                        this.setupScrollListener();
                        this.updateInitialState();
                    }
                    
                    collectSections() {
                        const navItems = Array.from(document.querySelectorAll('.nav__item:not(.nav__item--lang)'));
                        
                        this.sections = navItems
                            .map((navItem, index) => {
                                const navLink = navItem.querySelector('.nav__link');
                                const progressFiller = navItem.querySelector('.nav-item-progress');
                                
                                if (!navLink || !progressFiller) return null;
                                if (navLink.classList.contains('nav__link--logo')) return null;
                                
                                const href = navLink.getAttribute('href');
                                if (!href || !href.startsWith('#')) return null;
                                
                                const sectionId = href.substring(1);
                                const sectionElement = document.getElementById(sectionId);
                                
                                if (!sectionElement) return null;
                                
                                return {
                                    id: sectionId,
                                    element: sectionElement,
                                    navItem: navItem,
                                    progressFiller,
                                    navLink,
                                    index
                                };
                            })
                            .filter(Boolean);
                    }
                    
                    setupIntersectionObserver() {
                        const options = {
                            root: null,
                            rootMargin: '-20% 0px -20% 0px',
                            threshold: this.INTERSECTION_THRESHOLD
                        };
                        
                        this.observer = new IntersectionObserver((entries) => {
                            entries.forEach(entry => {
                                if (entry.isIntersecting) {
                                    const sectionInfo = this.sections.find(s => s.element === entry.target);
                                    if (sectionInfo) {
                                        this.setCurrentSection(sectionInfo);
                                    }
                                }
                            });
                        }, options);
                        
                        this.sections.forEach(section => {
                            this.observer.observe(section.element);
                        });
                    }
                    
                    setupScrollListener() {
                        window.addEventListener('locomotiveScroll', (event) => {
                            this.handleScroll(event.detail);
                        });
                        
                        window.addEventListener('scroll', () => {
                            this.handleScroll({
                                y: window.scrollY,
                                limit: document.documentElement.scrollHeight - window.innerHeight,
                                direction: 'down'
                            });
                        }, { passive: true });
                    }
                    
                    handleScroll(scrollInfo) {
                        if (this.isScrolling) return;
                        
                        this.isScrolling = true;
                        
                        if (this.scrollTimeout) {
                            clearTimeout(this.scrollTimeout);
                        }
                        
                        this.scrollTimeout = setTimeout(() => {
                            requestAnimationFrame(() => {
                                this.updateProgress(scrollInfo);
                                this.isScrolling = false;
                            });
                        }, this.SCROLL_THROTTLE);
                    }
                    
                    setCurrentSection(sectionInfo) {
                        if (this.currentSection === sectionInfo) return;
                        
                        if (this.currentSection) {
                            this.currentSection.navLink.classList.remove('active-section');
                        }
                        
                        this.currentSection = sectionInfo;
                        this.currentSection.navLink.classList.add('active-section');
                        
                        this.updateProgress();
                    }
                    
                    updateProgress(scrollInfo) {
                        if (!this.currentSection) return;
                        
                        const sectionProgress = this.calculateSectionProgress(this.currentSection, scrollInfo);
                        this.updateProgressDisplay(this.currentSection, sectionProgress);
                    }
                    
                    calculateSectionProgress(sectionInfo, scrollInfo) {
                        const element = sectionInfo.element;
                        const rect = element.getBoundingClientRect();
                        const windowHeight = window.innerHeight;
                        
                        // 如果 section 完全在視窗上方，進度為 100%
                        if (rect.bottom < 0) return 100;
                        // 如果 section 完全在視窗下方，進度為 0%
                        if (rect.top > windowHeight) return 0;
                        
                        // 重新設計的進度計算邏輯 - 更平滑且不會跑太快
                        const sectionHeight = rect.height;
                        const viewportHeight = windowHeight;
                        
                        // 計算進度的關鍵點
                        const sectionTop = rect.top;
                        const sectionBottom = rect.bottom;
                        
                        let progress = 0;
                        
                        // 階段1：section 進入視窗 (0% -> 30%)
                        if (sectionTop > 0) {
                            // section 還沒完全進入視窗
                            const entryProgress = Math.max(0, (viewportHeight - sectionTop) / viewportHeight);
                            progress = entryProgress * 30;
                        }
                        // 階段2：section 在視窗中滾動 (30% -> 85%)
                        else if (sectionBottom > viewportHeight * 0.5) {
                            // section 主要內容在視窗中
                            const scrollDistance = Math.abs(sectionTop);
                            const maxScrollForThisPhase = sectionHeight * 0.6; // 60% 的 section 高度
                            const scrollProgress = Math.min(1, scrollDistance / maxScrollForThisPhase);
                            progress = 30 + (scrollProgress * 55); // 30% + 55% = 85%
                        }
                        // 階段3：section 即將離開視窗 (85% -> 100%)
                        else {
                            // section 底部接近視窗底部
                            const exitProgress = Math.max(0, (viewportHeight * 0.5 - sectionBottom) / (viewportHeight * 0.5));
                            progress = 85 + (exitProgress * 15); // 85% + 15% = 100%
                        }
                        
                        return Math.max(0, Math.min(100, progress));
                    }
                    
                    updateProgressDisplay(sectionInfo, progress) {
                        const { progressFiller, navLink, index } = sectionInfo;
                        
                        this.sections.forEach((section, idx) => {
                            if (section === sectionInfo) return;
                            
                            let fillPercent = 0;
                            if (idx < index) {
                                fillPercent = 100;
                            } else if (idx > index) {
                                fillPercent = 0;
                            }
                            
                            section.progressFiller.style.width = fillPercent + '%';
                            section.navLink.style.setProperty('--progress-text-start', fillPercent + '%');
                            section.navLink.classList.toggle('progress-filled', fillPercent === 100);
                        });
                        
                        progressFiller.style.width = progress + '%';
                        navLink.style.setProperty('--progress-text-start', progress + '%');
                        navLink.classList.toggle('progress-filled', progress === 100);
                    }
                    
                    updateInitialState() {
                        const viewportCenter = window.innerHeight / 2;
                        let closestSection = null;
                        let closestDistance = Infinity;
                        
                        this.sections.forEach(section => {
                            const rect = section.element.getBoundingClientRect();
                            const sectionCenter = rect.top + rect.height / 2;
                            const distance = Math.abs(sectionCenter - viewportCenter);
                            
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                closestSection = section;
                            }
                        });
                        
                        if (closestSection) {
                            this.setCurrentSection(closestSection);
                        }
                    }
                    
                    onNavigationClick(targetSectionId) {
                        const targetSection = this.sections.find(s => s.id === targetSectionId);
                        if (!targetSection) return;
                        
                        this.setCurrentSection(targetSection);
                        
                        setTimeout(() => {
                            this.updateProgress();
                        }, 500);
                    }
                    
                    destroy() {
                        if (this.observer) {
                            this.observer.disconnect();
                        }
                        
                        if (this.scrollTimeout) {
                            clearTimeout(this.scrollTimeout);
                        }
                    }
                }
                
                // 全域實例
                let sectionProgressTracker = null;
                
                // 自動初始化
                document.addEventListener('DOMContentLoaded', () => {
                    sectionProgressTracker = new SectionProgressTracker();
                });
                
                // 暴露到全域
                window.getSectionProgressTracker = () => sectionProgressTracker;
            }
        </script> <script type="module" src="/kemeko.morphusai/_astro/BaseLayout.astro_astro_type_script_index_1_lang.DpYp50De.js"></script> </div> </body></html>